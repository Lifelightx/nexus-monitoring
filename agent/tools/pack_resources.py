#!/usr/bin/env python3
import os
import sys

def pack_resources(source_dir, output_file):
    print(f"Packing resources from {source_dir} to {output_file}")
    
    resources = {}
    
    try:
        # Walk through source directory
        for root, dirs, files in os.walk(source_dir):
            for file in files:
                if not file.endswith('.js'):
                    continue
                    
                abs_path = os.path.join(root, file)
                rel_path = os.path.relpath(abs_path, source_dir)
                
                with open(abs_path, 'rb') as f:
                    content = f.read()
                    
                # Convert to hex string for C++ literal (avoids escaping issues)
                hex_content = ''.join([f'\\x{b:02x}' for b in content])
                resources[rel_path] = hex_content
                print(f"  Packed {rel_path} ({len(content)} bytes)")

        # Generate C++ header
        with open(output_file, 'w') as f:
            f.write("#pragma once\n")
            f.write("#include <map>\n")
            f.write("#include <string>\n\n")
            f.write("namespace nexus {\n")
            f.write("namespace orchestrator {\n\n")
            f.write("// Auto-generated by pack_resources.py\n")
            f.write("const std::map<std::string, std::string> nodejs_files = {\n")
            
            for path, content in resources.items():
                f.write(f'    {{"{path}", "{content}"}},\n')
                
            f.write("};\n\n")
            f.write("} // namespace orchestrator\n")
            f.write("} // namespace nexus\n")
            
        print(f"Successfully generated {output_file}")
            
    except Exception as e:
        print(f"Error packing resources: {e}")
        sys.exit(1)

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: pack_resources.py <source_dir> <output_file>")
        sys.exit(1)
        
    pack_resources(sys.argv[1], sys.argv[2])
